package main

// The spelling correction algorithm below is adapted from: https://norvig.com/spell-correct.html

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os/exec"
)

const alphabet string = "abcdefghijklmnopqrstuvwxyz"

type Pair struct {
	L, R string
}

type SpellChecker struct {
	wordCounts map[string]int
}

func (sc *SpellChecker) Init() {

	// Run python script to download and create a language model of bit.txt
	err := exec.Command("python3", "/go/src/spellchecker/build_language_model.py").Run()

	if err != nil {
		panic(fmt.Sprintf("Failed to run python script to process words: %v", err.Error()))
	}

	// Load the file that contains word counts (language model) generated by the python script
	filename := "word_counts.txt"
	plan, _ := ioutil.ReadFile(filename)

	err = json.Unmarshal(plan, &sc.wordCounts)

	if err != nil {
		panic("Failed to load word counts.")
	}
}

func getSplits(w string) []Pair {
	var pairs []Pair

	for i := 0; i < len(w)+1; i++ {
		currPair := Pair{w[:i], w[i:]}
		pairs = append(pairs, currPair)
	}

	return pairs
}

func getDeletes(splits []Pair) []string {
	var result []string

	for i := 0; i < len(splits); i++ {
		if len(splits[i].R) > 0 {
			curr := splits[i].L + splits[i].R[1:]
			result = append(result, curr)
		}
	}

	return result
}

func getTransposes(splits []Pair) []string {
	var result []string

	for i := 0; i < len(splits); i++ {
		r := splits[i].R
		l := splits[i].L

		if len(r) > 1 {
			curr := l + string(r[1]) + string(r[0]) + r[2:]
			result = append(result, curr)
		}
	}

	return result
}

func getReplaces(splits []Pair) []string {
	var result []string

	for i := 0; i < len(splits); i++ {
		for j := 0; j < len(alphabet); j++ {
			if len(splits[i].R) > 0 {
				curr := splits[i].L + string(alphabet[j]) + splits[i].R[1:]
				result = append(result, curr)
			}
		}
	}

	return result
}

func getInserts(splits []Pair) []string {
	var result []string

	for i := 0; i < len(splits); i++ {
		for j := 0; j < len(alphabet); j++ {
			curr := splits[i].L + string(alphabet[j]) + splits[i].R
			result = append(result, curr)
		}
	}

	return result
}

// Removes duplicates from slice
// Source: https://gist.github.com/alioygur/16c66b4249cb42715091fe010eec7e33#file-unique_slice-go-L23
func SliceUniq(s []string) []string {
	for i := 0; i < len(s); i++ {
		for i2 := i + 1; i2 < len(s); i2++ {
			if s[i] == s[i2] {
				// delete
				s = append(s[:i2], s[i2+1:]...)
				i2--
			}
		}
	}
	return s
}

// Get list of words 1 edit distance away from a given string
func edit1(w string) []string {
	var result []string

	// Built partial lists
	splits := getSplits(w)
	deletes := getDeletes(splits)
	transposes := getTransposes(splits)
	replaces := getReplaces(splits)
	inserts := getInserts(splits)

	// Combine
	result = append(result, append(inserts, append(replaces, append(transposes, deletes...)...)...)...)

	// Return unique results
	return SliceUniq(result)
}

// Get list of words 2 edit distances away from a given string
func edit2(w string) []string {
	var result []string

	// Build list of one edit
	edits1 := edit1(w)

	// Build list of two edits
	var edits2 []string
	for i := 0; i < len(edits1); i++ {
		edits2 = append(edits2, edit1(edits1[i])...)
	}

	// Combine
	result = append(result, append(edits1, edits2...)...)

	// Return unique results
	return SliceUniq(result)
}

// Get words that are found in the language model (word counts)
func (sc *SpellChecker) getKnownWords(words []string) []string {
	var result []string

	for _, word := range words {
		if _, ok := sc.wordCounts[word]; ok {
			result = append(result, word)
		}
	}

	return result
}

func (sc *SpellChecker) getMostFrequent(words []string) string {

	// Initialize helper variables
	mostFreqWord := ""
	maxCount := 0

	// Find most frequent word
	for _, word := range words {
		if _, ok := sc.wordCounts[word]; ok {
			if sc.wordCounts[word] > maxCount {
				mostFreqWord = word
				maxCount = sc.wordCounts[word]
			}
		}
	}

	return mostFreqWord
}

func (sc *SpellChecker) getBestCandidate(word string) string {
	var candidates []string

	// Plan A: Try given word
	candidates = sc.getKnownWords([]string{word})
	if candidates != nil {
		return sc.getMostFrequent(candidates)
	}

	// Plan B: Try words 1 edit distance away
	candidates = sc.getKnownWords(edit1(word))
	if candidates != nil {
		return sc.getMostFrequent(candidates)
	}

	// Plan C: Try words 2 edit distances away
	candidates = sc.getKnownWords(edit2(word))
	if candidates != nil {
		return sc.getMostFrequent(candidates)
	}

	// Plan D: Return given word
	return word
}

// Return the best guess
func (sc *SpellChecker) correct(word string) string {
	fmt.Printf("\nCorrecting: %v", word)
	return sc.getBestCandidate(word)
}
